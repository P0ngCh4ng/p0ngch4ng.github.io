<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><title>Haskell練習3</title><meta name="next-head-count" content="3"/><link rel="preload" href="/_next/static/css/b19239382bd9f6e7.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b19239382bd9f6e7.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-7ee66019f7f6d30f.js" defer=""></script><script src="/_next/static/chunks/framework-db825bd0b4ae01ef.js" defer=""></script><script src="/_next/static/chunks/main-424107595f363128.js" defer=""></script><script src="/_next/static/chunks/pages/_app-deb173bd80cbaa92.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-802f20735a68ccca.js" defer=""></script><script src="/_next/static/2dB3tjWQdq4t9bG_S6WUs/_buildManifest.js" defer=""></script><script src="/_next/static/2dB3tjWQdq4t9bG_S6WUs/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div>Haskell練習3<br/>2022-11-19<br/><div><h2>問題4</h2>
<p>ボゴソートを作成</p>
<pre><code>bogosort :: (Show a,Ord a) => [a] -> IO [a]
bogosort [] = return []
bogosort xs = do
 xs' &#x3C;- shuffle xs
 if isSort xs' then return xs' else bogosort xs' 

isSort :: (Show a,Ord a) => [a] -> Bool
isSort [] = True
isSort [x] = trace(show x) True
isSort (x:y:xs) = if x > y then False else isSort $ res
 where
   res = y:xs
   

main :: IO ()
main = do
 xs &#x3C;- shuffle [1..9]
 print  xs
 print =&#x3C;&#x3C; bogosort xs
  
</code></pre>
<p>shuffle関数は<a href="https://p0ngch4ng.github.io/posts/haskell1114">前回の頁を参照</a>
ボゴソートのアルゴリズムは、ランダムにリストを並び換え、ソートされるまで繰り返すというもの。</p>
<p>関数bogosortの実態はディスパッチャの様な役割を果たしていて、isSort関数に渡し、ソートされるまでshuffle関数に
繰返し渡す。</p>
<p>isSort関数は、再帰で先頭と次の数を比較し続ける。</p>
<p>isSort関数のパターンマッチングについて少しほりさげると、
<code>isSort (x:y:xs) =  (x:y:xs) = if x > y then False else isSort $ y:xs</code>
この行では、リストが２要素以上或る場合、比較する。
先頭２数がソートされていれば、先頭の要素を抜いたリストを次のループに渡す。</p>
<p><code>isSort [x] = trace(show x) True</code>
１要素しかない場合、整列は完了しているのでTrueを返す。</p>
</div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"postData":{"id":"haskell20221119","contentHtml":"\u003ch2\u003e問題4\u003c/h2\u003e\n\u003cp\u003eボゴソートを作成\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003ebogosort :: (Show a,Ord a) =\u003e [a] -\u003e IO [a]\nbogosort [] = return []\nbogosort xs = do\n xs' \u0026#x3C;- shuffle xs\n if isSort xs' then return xs' else bogosort xs' \n\nisSort :: (Show a,Ord a) =\u003e [a] -\u003e Bool\nisSort [] = True\nisSort [x] = trace(show x) True\nisSort (x:y:xs) = if x \u003e y then False else isSort $ res\n where\n   res = y:xs\n   \n\nmain :: IO ()\nmain = do\n xs \u0026#x3C;- shuffle [1..9]\n print  xs\n print =\u0026#x3C;\u0026#x3C; bogosort xs\n  \n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eshuffle関数は\u003ca href=\"https://p0ngch4ng.github.io/posts/haskell1114\"\u003e前回の頁を参照\u003c/a\u003e\nボゴソートのアルゴリズムは、ランダムにリストを並び換え、ソートされるまで繰り返すというもの。\u003c/p\u003e\n\u003cp\u003e関数bogosortの実態はディスパッチャの様な役割を果たしていて、isSort関数に渡し、ソートされるまでshuffle関数に\n繰返し渡す。\u003c/p\u003e\n\u003cp\u003eisSort関数は、再帰で先頭と次の数を比較し続ける。\u003c/p\u003e\n\u003cp\u003eisSort関数のパターンマッチングについて少しほりさげると、\n\u003ccode\u003eisSort (x:y:xs) =  (x:y:xs) = if x \u003e y then False else isSort $ y:xs\u003c/code\u003e\nこの行では、リストが２要素以上或る場合、比較する。\n先頭２数がソートされていれば、先頭の要素を抜いたリストを次のループに渡す。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eisSort [x] = trace(show x) True\u003c/code\u003e\n１要素しかない場合、整列は完了しているのでTrueを返す。\u003c/p\u003e\n","title":"Haskell練習3","date":"2022-11-19","tag":"programming"}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"haskell20221119"},"buildId":"2dB3tjWQdq4t9bG_S6WUs","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>