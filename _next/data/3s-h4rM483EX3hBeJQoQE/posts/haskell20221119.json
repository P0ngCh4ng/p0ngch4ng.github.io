{"pageProps":{"postData":{"id":"haskell20221119","contentHtml":"<h2>問題4</h2>\n<p>ボゴソートを作成</p>\n<pre><code>bogosort :: (Show a,Ord a) => [a] -> IO [a]\nbogosort [] = return []\nbogosort xs = do\n xs' &#x3C;- shuffle xs\n if isSort xs' then return xs' else bogosort xs' \n\nisSort :: (Show a,Ord a) => [a] -> Bool\nisSort [] = True\nisSort [x] = trace(show x) True\nisSort (x:y:xs) = if x > y then False else isSort $ res\n where\n   res = y:xs\n   \n\nmain :: IO ()\nmain = do\n xs &#x3C;- shuffle [1..9]\n print  xs\n print =&#x3C;&#x3C; bogosort xs\n  \n</code></pre>\n<p>shuffle関数は<a href=\"https://p0ngch4ng.github.io/posts/haskell1114\">前回の頁を参照</a>\nボゴソートのアルゴリズムは、ランダムにリストを並び換え、ソートされるまで繰り返すというもの。</p>\n<p>関数bogosortの実態はディスパッチャの様な役割を果たしていて、isSort関数に渡し、ソートされるまでshuffle関数に\n繰返し渡す。</p>\n<p>isSort関数は、再帰で先頭と次の数を比較し続ける。</p>\n<p>isSort関数のパターンマッチングについて少しほりさげると、\n<code>isSort (x:y:xs) =  (x:y:xs) = if x > y then False else isSort $ y:xs</code>\nこの行では、リストが２要素以上或る場合、比較する。\n先頭２数がソートされていれば、先頭の要素を抜いたリストを次のループに渡す。</p>\n<p><code>isSort [x] = trace(show x) True</code>\n１要素しかない場合、整列は完了しているのでTrueを返す。</p>\n","title":"Haskell練習3","date":"2022-11-19","tag":"programming"}},"__N_SSG":true}